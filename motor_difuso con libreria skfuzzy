from owlready2 import *
from pathlib import Path
import json
import numpy as np
import skfuzzy as fuzz

POBLADA_OWL = Path("ontologia_poblada.rdf")
JSON_FILE = Path("escenario.json")

# =============================================================================
# DATOS
# =============================================================================

DB_INCIDENTES_BASE = {
    "Fallo":         {"prob": 0.35, "imp": 0.15}, 
    "Interferencia": {"prob": 0.55, "imp": 0.37},
    "Ataque":        {"prob": 0.52, "imp": 0.58},
    "Sabotaje":      {"prob": 0.33, "imp": 0.76}
}

DB_ACCIONES = {
    "Muy Bajo": {"accion": "Monitorizar",                "red_p": 0.00, "red_i": 0.00},
    "Bajo":     {"accion": "Respuesta local",            "red_p": 0.10, "red_i": 0.10},
    "Medio":    {"accion": "Aislar y contener",          "red_p": 0.20, "red_i": 0.30},
    "Alto":     {"accion": "Despliegue de contingencia", "red_p": 0.20, "red_i": 0.40},
    "Critico":  {"accion": "Escalada inmediata",         "red_p": 0.30, "red_i": 0.50}
}



# =============================================================================
# LóGICA DIFUSA CON NUEVA LIBRERIA
# =============================================================================

x_pi = np.arange(0, 1.01, 0.01)      # Probabilidad e Impacto del 0 al 1
x_riesgo = np.arange(0, 1.01, 0.01)  # Riesgo del 0 al 1

# Curvas de Entrada (Probabilidad / Impacto)
pi_mfs = {
    "Muy Baja": fuzz.trapmf(x_pi, [0.0, 0.0, 0.1, 0.2]),
    "Baja":     fuzz.trimf (x_pi, [0.1, 0.25, 0.4]),
    "Media":    fuzz.trimf (x_pi, [0.3, 0.45, 0.6]),
    "Alta":     fuzz.trimf (x_pi, [0.5, 0.65, 0.8]),
    "Muy Alta": fuzz.trapmf(x_pi, [0.7, 0.9, 1.0, 1.0]),
}

# Curvas de Salida (Riesgo)
riesgo_mfs = {
    "Muy Bajo": fuzz.trapmf(x_riesgo, [0.0, 0.0, 0.1, 0.2]),
    "Bajo":     fuzz.trimf (x_riesgo, [0.1, 0.25, 0.4]),
    "Medio":    fuzz.trimf (x_riesgo, [0.3, 0.45, 0.6]),
    "Alto":     fuzz.trimf (x_riesgo, [0.5, 0.65, 0.8]),
    "Critico":  fuzz.trapmf(x_riesgo, [0.7, 0.9, 1.0, 1.0]),
}

def get_membership_skfuzzy(valor_crisp):
    vector = {}
    for etiqueta, curva in pi_mfs.items():
        vector[etiqueta] = fuzz.interp_membership(x_pi, curva, valor_crisp)
    return vector


# =============================================================================
# Funciones normalizar, ajustar y mitigar 
# =============================================================================
def normalizar(vector):
    max_val = max(vector.values())
    if max_val == 0: return vector
    return {k: v / max_val for k, v in vector.items()}

def aplicar_ajuste(vector, nivel):
    coefs = {"Ninguno":(1.0, 1.0), "Leve":(0.9, 1.1), "Moderado":(0.75, 1.3), "Fuerte":(0.5, 1.6)}
    m_low, m_high = coefs.get(nivel, (1.0, 1.0))
    nuevo = {}
    for k, v in vector.items():
        if k in ["Muy Baja", "Baja", "Media"]: nuevo[k] = v * m_low
        else:                                  nuevo[k] = v * m_high
    return normalizar(nuevo)

def aplicar_mitigacion(vector, factor):
    nuevo = {}
    for k, v in vector.items():
        if k in ["Alta", "Muy Alta"]: nuevo[k] = v * (1.0 - factor)
        else:                         nuevo[k] = v 
    return normalizar(nuevo)


# =============================================================================
# INFERENCIA Y DEFUZZIFICACIÓN
# =============================================================================
def inferencia_y_defuzzificacion(p_vec, i_vec):
    MATRIZ = {
        ("Muy Baja", "Muy Baja"): "Muy Bajo", ("Muy Baja", "Baja"): "Muy Bajo", ("Muy Baja", "Media"): "Bajo",     ("Muy Baja", "Alta"): "Bajo",     ("Muy Baja", "Muy Alta"): "Medio",
        ("Baja", "Muy Baja"):     "Muy Bajo", ("Baja", "Baja"):     "Bajo",     ("Baja", "Media"):     "Bajo",     ("Baja", "Alta"):     "Medio",    ("Baja", "Muy Alta"):     "Alto",
        ("Media", "Muy Baja"):    "Bajo",     ("Media", "Baja"):    "Bajo",     ("Media", "Media"):    "Medio",    ("Media", "Alta"):    "Alto",     ("Media", "Muy Alta"):    "Alto",
        ("Alta", "Muy Baja"):     "Bajo",     ("Alta", "Baja"):     "Medio",    ("Alta", "Media"):     "Alto",     ("Alta", "Alta"):     "Alto",     ("Alta", "Muy Alta"):     "Critico",
        ("Muy Alta", "Muy Baja"): "Medio",    ("Muy Alta", "Baja"): "Alto",     ("Muy Alta", "Media"): "Alto",     ("Muy Alta", "Alta"): "Critico",  ("Muy Alta", "Muy Alta"): "Critico",
    }

    riesgo = {"Muy Bajo": 0.0, "Bajo": 0.0, "Medio": 0.0, "Alto": 0.0, "Critico": 0.0}
    
    for p_label, p_val in p_vec.items():
        if p_val == 0: continue
        for i_label, i_val in i_vec.items():
            if i_val == 0: continue
            fuerza = min(p_val, i_val)
            nivel = MATRIZ.get((p_label, i_label))
            riesgo[nivel] = max(riesgo[nivel], fuerza)

    # Se hacen los cortes, la agregación (suma de montañitas) y coge el centro de gravedad
    agregado = np.zeros_like(x_riesgo)
    for nivel, activacion in riesgo.items():
        if activacion > 0:
            corte = np.fmin(activacion, riesgo_mfs[nivel])
            agregado = np.fmax(agregado, corte)


    if np.sum(agregado) == 0:
        return riesgo, 0.0
    
    score = fuzz.defuzz(x_riesgo, agregado, 'centroid')
    return riesgo, score
#Coge el mas alto no prioridad 
def obtener_nivel_principal(riesgo_vector):
   return max(riesgo_vector, key=riesgo_vector.get)



# =============================================================================
# 3. REGLAS
# =============================================================================
def evaluar_contexto(activo_data, mision_data):
    ajuste_p = "Ninguno"
    ajuste_i = "Ninguno"
    
    con = activo_data.get("conexiones_externas", 0)
    if con >= 5:   ajuste_p = "Fuerte"
    elif con >= 2: ajuste_p = "Moderado"

    doms_activo = activo_data.get("dominios", [])
    if len(doms_activo) > 1:
        if ajuste_i == "Ninguno": ajuste_i = "Moderado" 
        elif ajuste_i == "Leve" : ajuste_i = "Moderado"

    deps = activo_data.get("dependencias_criticas", 0)
    if deps > 3: ajuste_i = "Moderado"

    fase = mision_data.get("fase", "Planeamiento")
    if fase == "Ejecucion": ajuste_i = "Fuerte"

    return ajuste_p, ajuste_i

# =============================================================================
#  EJECUCIÓN PRINCIPAL
# =============================================================================
try:
    with open(JSON_FILE, "r", encoding="utf-8") as f:
        json_data = json.load(f)
except:
    print("ERROR no tengo JSON"); exit()

misiones_dict = {m["id"]: m for m in json_data["misiones"]}
activos_dict  = {a["id"]: a for a in json_data["activos"]}


for i_data in json_data["incidentes"]:
    inc_id = i_data["id"]
    tipo = i_data.get("tipo_incidente", "Fallo")
    val_base = DB_INCIDENTES_BASE.get(tipo, {"prob": 0.5, "imp": 0.5})

    for act_id in i_data["afectaA"]:
        act_context = activos_dict.get(act_id)
        mision_id   = act_context.get("perteneceAMision")
        mis_context = misiones_dict.get(mision_id, {})

        ajuste_p, ajuste_i = evaluar_contexto(act_context, mis_context)

        vec_p = get_membership_skfuzzy(val_base["prob"])
        vec_i = get_membership_skfuzzy(val_base["imp"])
        
        vec_p_adj = aplicar_ajuste(vec_p, ajuste_p)
        vec_i_adj = aplicar_ajuste(vec_i, ajuste_i)
        
        riesgo_inh_vec, score_inh = inferencia_y_defuzzificacion(vec_p_adj, vec_i_adj)
        nivel_inh = obtener_nivel_principal(riesgo_inh_vec)
        
        datos_accion = DB_ACCIONES.get(nivel_inh)
        
        print(f"INCIDENTE: {inc_id} | ACTIVO: {act_id}")
        print(f"RIESGO INHERENTE: {nivel_inh.upper():<10} (Score: {score_inh:.3f}/1.00)")
        
        if datos_accion:
            print(f"ACCIÓN: {datos_accion['accion'].upper()}")
            
            vec_p_res = aplicar_mitigacion(vec_p_adj, datos_accion['red_p'])
            vec_i_res = aplicar_mitigacion(vec_i_adj, datos_accion['red_i'])
            
            riesgo_res_vec, score_res = inferencia_y_defuzzificacion(vec_p_res, vec_i_res)
            nivel_res = obtener_nivel_principal(riesgo_res_vec)
            
            diff = score_inh - score_res
            print(f"RIESGO RESIDUAL:  {nivel_res.upper():<10} (Score: {score_res:.3f}/1.00) [Bajada: {diff:.3f}]")
        else:
            print("ACCIÓN: No definida")
        print("-" * 70)